#+options: toc:t num:nil html-postamble:t
#+title: Curso de Introducción a Python
#+author:  @@html:<br>@@ Daniel Ballesteros Chávez,@@html:<br>@@ Jorge F. Becerril Cejudo @@html:<br>@@ Karla J. Melo Rascon  @@html:<br>@@ 
#+email:   huehueocelotl@gmail.com
#+LANGUAGE: es
#+date:  <2024-10-13 Sun>
#+INFOJS_OPT: view:info toc:nil

#+HTML_HEAD: <link href=' http://fonts.googleapis.com/css?family=Grandstander' rel='stylesheet' type='text/css'>
#+HTML_HEAD: <style>  body { background:#F5F5F7 ; max-width: 768px; margin: 20px auto; color: ; font-family: 'Grandstander';} </style>
#+HTML_HEAD: <style> :root {--col0: #1b263b; --col1: #edf2f4; --col2: #03C988; --col3: #ef233c; --col4: #d90429; --col5: #173f5f;} </style>
#+HTML_HEAD:  <style> h2 { background: var(--col2) ; color: var(--col0);  font-weight: bold; display: block; padding: 10px 20px;  } </style>
#+HTML_HEAD: <style> .thm {background-color: #BFF2FF; padding: 10px 20px 10px 20px; box-shadow: 0px 0px 24px 0px rgba(66, 68, 90, 1); border: 1px solid #404040; border-radius: 25px;}</style>
#+HTML_HEAD: <style> .thm:before {content: "Theorem: "; font-weight: bold}</style>
#+HTML_HEAD: <style> .mydef {background-color: #A2EEB2; padding: 10px 20px 10px 20px; box-shadow: 0px 0px 24px 0px rgba(66, 68, 90, 1); border: 1px solid #404040; border-radius: 25px;}</style>
#+HTML_HEAD: <style> .mydef:before {content: "Definition: "; font-weight: bold}</style>
#+HTML_HEAD: <style> .prop {background-color:  #FFAE33; padding: 10px 20px 10px 20px; box-shadow: 0px 0px 24px 0px rgba(66, 68, 90, 1); border: 1px solid #404040; border-radius: 25px;}</style>
#+HTML_HEAD: <style> .prop:before {content: "Proposition: "; font-weight: bold}</style>
#+HTML_HEAD: <style> .xmpl {background-color: #DBEDDC; padding: 10px 20px 10px 20px; box-shadow: 0px 0px 24px 0px rgba(66, 68, 90, 1); border: 1px solid #404040; border-radius: 25px;}</style>
#+HTML_HEAD: <style> .xmpl:before {content: "Example: "; font-weight: bold}</style>
#+HTML_HEAD: <style> .warn {background-color: #FFA500; padding: 10px 20px 10px 20px; box-shadow: 0px 0px 24px 0px rgba(66, 68, 90, 1); border: 1px solid #404040; border-radius: 25px;}</style>
#+HTML_HEAD: <style> .warn:before {content: "Important remark: "; font-weight: bold}</style>
#+HTML_HEAD: <style>  th {background-color: #f55fc3;} tr:nth-child(odd) {background-color: #e2e2e2;}  table tr:hover {background-color: #d0c6e5;} </style>
#+HTML_HEAD: <style>  p {text-align: justify;} </style>
#+HTML_HEAD: <style>  pre {border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; padding: 8pt; font-family: monospace; overflow: auto; margin: 1.2em; border-radius: 10px;}</style>
#+HTML_HEAD: <style>code {background-color: #ccc}</style>

#+begin_export html
 <br><br><br>
 #+end_export
 #+begin_export html
 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
 #+end_export

[[./index.html][Home]]
* Introducción

Estas notas son empleadas como material didáctico para un curso introdcutorio de programación en Python.

Su contenido está tomado principalmente de las siguentes fuentes:

   +  [[https://docs.python.org/3/][Python Documentation]]
   +  [[https://es.wikipedia.org/wiki/Python][es.wiki/Python]]

Python es un lenguaje de alto nivel de programación interpretado y tiene la característica de ser un código muy fácil de leer. Se trata de un lenguaje de programación multiparadigma, ya que soporta parcialmente la orientación a objetos, programación imperativa y la llamada programación funcional. Es un lenguaje interpretado, dinámico y que corre en varios sistemas operativos.

Administrado por Python Software Foundation, posee una licencia de código abierto, denominada Python Software Foundation License. Python se clasifica constantemente como uno de los lenguajes de programación más populares para

    Análisis de datos
    Desarollo de software
    Modelos de Machine Learning
    Modelos de Redes Neuronales

* Obtener python

#+BEGIN_SRC python :eval no :results output :exports both :session s1
print("Hola Mundo!")
#+END_SRC

#+RESULTS:
: Hola Mundo!


+  Si cuentas con una cuenta gmail puedes utilizar de manera gratuita Google Colaborative (colab).
+  Desde la página https://www.python.org/downloads/ puedes hacer la descarga a cualquier sistema operativo.
+ Instala la version minimalista llamada [[https://docs.conda.io/projects/miniconda/en/latest/][Miniconda]] para cualquier sistema operativo.
+ Si cuentas con Linux/Debian  puedes simplemente hacer =sudo apt install python3= desde la terminal.

* Editor de texto y sintaxis

+ Operadores Lógicos :: =not=, =or=,  =and= (en correspondencia con =!=, =||= y =&&= de otros lenguajes)
+ Sangría o Indentación :: El contenido de los bloques de código será delimitado mediante espacio tabuladores.
+ Multi-línea :: Para indicar que una instrucción continua en el siguente renglón usamos =\= (diagonal invertida).
+ Comentarios 1 :: Para indicar un comentario dentro del código éstos se escriben entre tres apóstrofos de apertura y tres de cierre ='''comentario aquí'''=.
+ Comentarios 2 :: Alternativamente se utiliza el símbolo =#=, que se extiende hasta el final de la línea. 
+ Variables :: Los nombres de las varibales pueden contener números pero siempre comienzan con una letra. La asignación de su valor se hace mediante el símbolo ~=~, y esta se hace de manera dinámica, es decir, sin necesitad de especificar a priori su tipo.
+ Nombres reservados :: Existen palabras reservadas en python las cuales no pueden usarse para nombrar nuevas variables. A continuación una lista de ellas.

|--------+----------+---------|
| /      | <        | <        |
| and    | continue | finally |
| as     | def      | for     |
| assert | del      | from    |
| async  | elif     | global  |
| await  | else     | if      |
| break  | except   | import  |
| class  | False    | in      |

* Tipos de datos



| Tipo      | Clase                                                             | Notas                                               | Ejemplo                          |
|-----------+-------------------------------------------------------------------+-----------------------------------------------------+----------------------------------|
| str       | Cadena en determinado formato de codificación (UTF-8 por defecto) | Inmutable                                           | 'Cadena'                         |
| bytes     | Vector o array de bytes                                           | Inmutable                                           | b'Cadena'                        |
| list      | Secuencia                                                         | Mutable, puede contener objetos de diversos tipos   | [2.0, 'Cadena', True]            |
| tuple     | Secuencia                                                         | Inmutable, puede contener objetos de diversos tipos | (2.0, 'Cadena', True)            |
| set       | Conjunto                                                          | Mutable, sin orden, no contiene duplicados          | {2.0, 'Cadena', True}            |
| frozenset | Conjunto                                                          | Inmutable, sin orden, no contiene duplicados        | frozenset([4.0, 'Cadena', True]) |
| dict      | Diccionario                                                       | Grupo de pares clave:valor                          | {'key1': 1.0, 'key2': False}     |
| int       | Número entero                                                     | Precisión arbitraria                                | 52                               |
| float     | Número decimal                                                    | Coma flotante de doble precisión                    | 3.1416                           |
| complex   | Número complejo                                                   | Parte real y parte imaginaria j.                    | (2.5 + 4j)                       |
| bool      | Booleano                                                          | Valor booleano (verdadero o falso)                  | True o False                     |

Nota:\\
Mutable: si su contenido (o dicho valor) puede cambiarse en tiempo de ejecución.\\
Inmutable: si su contenido (o dicho valor) no puede cambiarse en tiempo de ejecución\\

Enteros
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print(4)
  print(type(4))
#+END_SRC

Float
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print(4/7.5)
  print(type(4/7.5))
#+END_SRC

Booleanos
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print(True)
  print(type(True))
#+END_SRC

Complejos
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print(4+5j)
  print(type(4+5j))
#+END_SRC

Cadenas
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print("Hola")
  print(type("Hola"))
#+END_SRC

Listas
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print([1,2,3,4,5])
  print(type([1,2,3,4,5]))
#+END_SRC

Diccionarios
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print({"a": 1, "b": 2})
  print(type({"a": 1, "b": 2}))
#+END_SRC

Tuplas
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print(("A",True,7))
  print(type(("A",True,7)))
#+END_SRC

Conjuntos
#+BEGIN_SRC python :eval no :results output :exports both :session s1
  print(set([1,2,3,4,5,4,3,2,1]))
  print(type(set([1,2,3,4,5,4,3,2,1])))
#+END_SRC

Fuciones asociadas a cada clase

#+BEGIN_SRC python :eval no :results output :exports both :session s1
print(dir(type(int)))
print(dir(type(list)))
#+END_SRC

#+RESULTS:
: ['__abstractmethods__', '__annotations__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__', '__dictoffset__', '__dir__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__or__', '__prepare__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__text_signature__', '__weakrefoffset__', 'mro']
: ['__abstractmethods__', '__annotations__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__', '__dictoffset__', '__dir__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__or__', '__prepare__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__text_signature__', '__weakrefoffset__', 'mro']

* Funciones
En python las funciones de sefinen con la palabra clave =def=, y en algunas ocaciones es común encontrarlas en la forma de =lambda= (como en el lenguaje Lisp).
El varlor devuelto por la función es indicado con la instrucción =return=.
El parámetro =*args= admite una tupla como argumentos de la función, mientras que el parámetro =**kwargs= admite un diccionario como argumentos.

A continuación algunos ejemplos clásicos.
** La suma de números
#+begin_src python :eval no :results output :session s1 :exports both 
def suma(x, y=5):
    return x + y  
print(suma(6), "-- por defecto, el valor de y es 5")
print(suma(6,4))
#+end_src

#+RESULTS:
: 11 -- por defecto, el valor de y es 5
: 10
** La suma de números usando =*args=
#+begin_src python :eval no :results output :session s1 :exports both 
def suma(*args):
    resultado = 0
    for num in args:
        resultado = (resultado + num)
    return resultado

print(suma(1,2,4,7))
#+end_src

#+RESULTS:
: 14

** La suma de números usando =**kwargs=
#+begin_src python :eval no  :results output :session s1 :exports both 
def suma(**kwargs):
    resultado = 0
    for llave, valor in kwargs.items():
        resultado = (resultado + valor)
    return resultado

print(suma(x=1,y=2,z=4,variable4=7))
#+end_src

#+RESULTS:
: 14

** La suma de números usando =lambda=
#+begin_src python :eval no  :results output :session s1 :exports both 
suma = lambda x, y=2: x + y

print(suma(4))
print(suma(4,6))
#+end_src

#+RESULTS:
: 6
: 10

* Condicionales

#+begin_src python :eval no :results output :session s1 :exports both
Nombre = "Usuario"
if Nombre == "Usuarioo":
    print("El usuario es Usuario")
else:
    print("No eres el usuario que esperaba")
#+end_src 

#+RESULTS:
: No eres el usuario que esperaba


#+begin_src python :eval no :results output :session s1 :exports both
Nombre = "Usuarioi"
if Nombre == "UsuarioP":
    print("La última letra es una \"P\"")
elif Nombre == "Usuarioi":
    print("La última letra es una \"i\"")
else:
    print("El usuario es Usuario")
#+end_src 

#+RESULTS:
: La última letra es una "i"

* Bucle for
#+begin_src python :eval no :results output :session s1 :exports both 
lista = ["A", "B", "a", "b", "c", "d"]
for i in lista:
    print(i)
#+end_src 

#+RESULTS:
: A
: B
: a
: b
: c
: d

#+begin_src python :eval no :results output :session s1 :exports both 
cadena = "Usuario"
for i in cadena:
    print(i)
#+end_src 

#+RESULTS:
: U
: s
: u
: a
: r
: i
: o

* Bucle while

#+begin_src python :eval no :results output :session s1 :exports both 
i = 0
while  i < 10:
    print("Indice número", i)
    i += 1 
#+end_src 

#+RESULTS:
#+begin_example
Indice número 0
Indice número 1
Indice número 2
Indice número 3
Indice número 4
Indice número 5
Indice número 6
Indice número 7
Indice número 8
Indice número 9
#+end_example

* Listas y Tuplas
** Listas
#+begin_src python :eval no :results output :session s1 :exports both 
lista = ["abc", 522, 3/2]
print(lista)
# Acceder a un elemento por su índice
print(lista[0])
#+end_src

#+RESULTS:
: ['abc', 522, 1.5]
: abc

#+begin_src python :eval no :results output :session s1 :exports both 
# Acceder a un elemento usando un índice negativo
print(lista[-1])
#+end_src

#+RESULTS:
: 1.5

#+begin_src python :eval no :results output :session s1 :exports both 
# Añadir un elemento al final de la lista
lista.append(True)  
print(lista)
#+end_src

#+RESULTS:
: ['abc', 522, 1.5, True]

#+begin_src python :eval no :results output :session s1 :exports both 
# Borra un elemento de la lista usando un índice (en este caso: True)
del lista[3]
print(lista)  
#+end_src

#+RESULTS:
: ['abc', 522, 1.5]

#+begin_src python :eval no :results output :session s1 :exports both 
# Re-asignar el valor del primer elemento de la lista
lista[0] = "guitarra"  
print(lista)
#+end_src

#+RESULTS:
: ['guitarra', 522, 1.5]

#+begin_src python :eval no :results output :session s1 :exports both 
# Mostrar los elementos de la lista del índice "0" al "2" (sin incluir este último)
print(lista[0:2] )
#+end_src

#+RESULTS:
: ['guitarra', 522]

#+begin_src python :eval no :results output :session s1 :exports both 
# Es posible anidar listas
lista_anidada = [lista, [True, 42]] 
print(lista_anidada)

# Acceder a un elemento de una lista dentro de otra lista (del segundo elemento, mostrar el primer elemento)
print(lista_anidada[1][0])
#+end_src

#+RESULTS:
: [['guitarra', 522, 1.5], [True, 42]]
: True

** Tuplas

#+begin_src python :eval no :results output :session s1 :exports both 
tupla = ("abc", 522, 3/2)
# Acceder a un elemento por su índice
print(tupla[0])
#+end_src

#+RESULTS:
: abc

#+begin_src python :eval no :results output :session s1 :exports both 
# Acceder a un elemento usando un índice negativo
print(tupla[-1])
#+end_src

#+RESULTS:
: 1.5

#+begin_src python :eval no :results output :session s1 :exports both 
# No es posible borrar (ni añadir) un elemento en una tupla, lo que provocará una excepción
del tupla[0]  
#+end_src

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/tmp/babel-ig8N8b/python-VxBVuo", line 2, in <module>
:     del tupla[0]  
:         ~~~~~^^^
: TypeError: 'tuple' object doesn't support item deletion

#+begin_src python :eval no :results output :session s1 :exports both 
# Tampoco es posible re-asignar el valor de un elemento en una tupla, lo que también provocará una excepción
tupla[0] = "guitarra" 
#+end_src

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/tmp/babel-ig8N8b/python-OFomB4", line 2, in <module>
:     tupla[0] = "guitarra" 
:     ~~~~~^^^
: TypeError: 'tuple' object does not support item assignment

#+begin_src python :eval no :results output :session s1 :exports both 
# También es posible anidar tuplas
tupla_anidada = (tupla, (True, 3.1415))  
print(tupla_anidada)
#+end_src

#+RESULTS:
: (('abc', 522, 1.5), (True, 3.1415))

#+begin_src python :eval no :results output :session s1 :exports both 
# Esto también es una tupla, aunque es recomendable ponerla entre paréntesis (recuerde que requiere, al menos, una coma)
1, 2, 3, "abc"
#+end_src

#+RESULTS:
: 1 2 3 abc

* Diccionarios
   + Para declarar un diccionario se usan las llaves {}. Contienen elementos separados por comas, donde cada elemento está formado por un par clave:valor (el símbolo : separa la clave de su valor correspondiente).
   + Los diccionarios son mutables, es decir, se puede cambiar el contenido de un valor en tiempo de ejecución.
   + En cambio, las claves de un diccionario deben ser inmutables. Esto quiere decir, por ejemplo, que no podremos usar ni listas ni diccionarios como claves.
   + El valor asociado a una clave puede ser de cualquier tipo de dato, incluso un diccionario.

#+begin_src python :eval no :results output :session s1 :exports both 
# Diccionario que tiene diferentes valores por cada clave, incluso una lista
diccionario = {"cadena": "abc", "numero": 452, "lista": [True, 42]}  
print(diccionario["numero"])
#+end_src

#+RESULTS:
: 452

#+begin_src python :eval no :results output :session s1 :exports both 
# Acceder a un elemento de una lista dentro de un valor (del valor de la clave "lista", mostrar el primer elemento)
 diccionario["lista"][0]  
#+end_src

#+RESULTS:
: True

#+begin_src python :eval no :results output :session s1 :exports both 
# Re-asignar el valor de una clave
diccionario["cadena"] = "xyz"  
print(diccionario["cadena"])
#+end_src

#+RESULTS:
: xyz

#+begin_src python :eval no :results output :session s1 :exports both 
# Insertar un nuevo elemento clave:valor
diccionario["decimal"] = 3.1415927  
print(diccionario["decimal"])
#+end_src

#+RESULTS:
: 3.1415927


#+begin_src python :eval no :results output :session s1 :exports both 
# También es posible que un valor sea un diccionario
diccionario_mixto = {"tupla": (True, 3.1415), "diccionario": diccionario}  
#+end_src

#+RESULTS:

#+begin_src python :eval no :results output :session s1 :exports both 
# Acceder a un elemento dentro de una lista, que se encuentra dentro de un diccionario
print(diccionario_mixto["diccionario"]["lista"][1]  )
#+end_src

#+RESULTS:
: 42

#+begin_src python :eval no :results output :session s1 :exports both 
# Sí es posible que una clave sea una tupla, pues es inmutable
diccionario = {("abc",): 42}  
print(diccionario)
#+end_src

#+RESULTS:
: {('abc',): 42}

#+begin_src python :eval no :results output :session s1 :exports both 
# No es posible que una clave sea una lista, pues es mutable, lo que provocará una excepción
diccionario = {["abc"]: 42}  
#+end_src

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/tmp/babel-ig8N8b/python-JCTu1E", line 2, in <module>
:     diccionario = {["abc"]: 42}  
:                   ^^^^^^^^^^^^^
: TypeError: unhashable type: 'list'

* Sentencia match-case

#+begin_src python :eval no :results output :session s1 :exports both 
x = 10
y = 30

match (x,y):
	case (10 ,40):  # los atributos "x" e "y" tienen el valor specificado
		print("Coordenada 10, 40")
	case (10 ,30):  # los atributos "x" e "y" tienen el valor specificado
		print("Coordenada 10, 30")
	case _:  # ninguna condición cumplida (default)
		print("La opción no fue encontrada")
#+end_src

#+RESULTS:
: Coordenada 10, 30

* Usando if, elif, else

#+begin_src python :eval no :results output :session s1 :exports both 
def calculadora(operacion, a, b):
    if operacion == 'sum':
        return a + b
    elif operacion == 'rest':
        return a - b
    elif operacion == 'mult':
       return a * b
    elif operacion == 'div':
       return a / b
    else:
        return None

print(calculadora('sum',3,7))
#+end_src

#+RESULTS:
: 10

* Usando diccionarios
#+begin_src python :eval no  :results output :session s1 :exports both 
def calculo(operacion, a, b):
    return {
        'sum': lambda: a + b,
        'rest': lambda: a - b,
        'mult': lambda: a * b,
        'div': lambda: a/b
    }.get(operacion, lambda: None)()

print(calculo('div',3,4))
#+end_src

#+RESULTS:
: 0.75

* Conjuntos
   
+ Los conjuntos se construyen mediante la expresión set(items), donde items es cualquier objeto iterable, como listas o tuplas. 
+ Los conjuntos no mantienen el orden ni contienen elementos duplicados.
+ Se suelen utilizar para eliminar duplicados de una secuencia, o para operaciones matemáticas como intersección, unión, diferencia y diferencia simétrica.

#+begin_src python :eval no :results output :session s1 :exports both 
conjunto_inmutable = frozenset(["a", "b", "a"])  # Se utiliza una lista como objeto iterable
print(conjunto_inmutable)
#+end_src

#+RESULTS:
: frozenset({'a', 'b'})

#+begin_src python :eval no :results output :session s1 :exports both 
# Primer conjunto mutable
conjunto1 = set(["a", "b", "a"])  
print(conjunto1)
#+end_src

#+RESULTS:
: {'a', 'b'}

#+begin_src python :eval no :results output :session s1 :exports both 
# Segundo conjunto mutable
conjunto2 = set(["a", "b", "c", "d"])  
print(conjunto2)
#+end_src

#+RESULTS:
: {'d', 'a', 'c', 'b'}


#+begin_src python :eval no :results output :session s1 :exports both 
# Intersección
conjunto1 & conjunto2  
#+end_src

#+RESULTS:
: {'a', 'b'}

#+begin_src python :eval no :results output :session s1 :exports both 
# Unión
print(conjunto1 | conjunto2  )
#+end_src

#+RESULTS:
: {'c', 'a', 'd', 'b'}


#+begin_src python :eval no :results output :session s1 :exports both 
# Diferencia (1)
conjunto1 - conjunto2  
#+end_src

#+begin_src python :eval no :results output :session s1 :exports both 
# Diferencia (2)
print(conjunto2 - conjunto1 )
#+end_src

#+RESULTS:
: {'c', 'd'}


#+begin_src python :eval no :results output :session s1 :exports both 
# Diferencia simétrica
print(conjunto1 ^ conjunto2  )
#+end_src

#+RESULTS:
: {'d', 'c'}

* Listas por comprensión
En python existe una manera más reducida para definir listas. 

Mediante la función =range()=

#+begin_src python :eval no :results output :session s1 :exports both 
# La siguente función crea una lista desde 0 hasta (n-1) 
x= range(5)
print(x)
for i in x:
    print(i)
#+end_src

#+RESULTS:
: range(0, 5)
: 0
: 1
: 2
: 3
: 4

Mediante el uso de los corchetes  =[]=
#+begin_src python :eval no :results output :session s1 :exports both 
print([i*(i+1) for i in range(5)])
#+end_src

#+RESULTS:
: [0, 2, 6, 12, 20]

#+begin_src python :eval no :results output :session s1 :exports both 
lista = [(i, i + 2) for i in range(5)]
print(lista)
#+end_src

#+RESULTS:
: [(0, 2), (1, 3), (2, 4), (3, 5), (4, 6)]


# #+begin_src python :eval  :results output :session s1 :exports both 
# lista = [for i in range(5): (i, i + 2) ]
# print(lista)
# #+end_src

# #+RESULTS:
# : Traceback (most recent call last):
# :   File "<stdin>", line 1, in <module>
# :   File "/tmp/babel-npHiT6/python-GVHYNs", line 1
# :     lista = [for i in range(5): (i, i + 2) ]
# :              ^^^
# : SyntaxError: invalid syntax

* Clases
Las clases se definen con la palabra clave =class=, seguida del nombre
de la clase y, si hereda de otras clases, los nombres de estas.  En
una clase, un método equivale a una función, y un atributo equivale a
una variable, por ejemplo, =_init_= es un método especial que se
ejecuta al instanciar la clase y que se usa generalmente para
inicializar atributos y ejecutar otros métodos necesarios.
Los métodos al ser funciones deben tener al menos un parámetro que puede ser =self=.
Los atributos que se desee que sean accesibles desde fuera de la clase se deben declarar usando =self= delante del nombre.


** Ejemplo de una clase
#+begin_src python :eval no  :results output :session s1 :exports both 
class Persona():
    def __init__(self, nombre, edad):
        self.nombre = nombre  # Un atributo llamado nombre
        self.edad = edad  # Otro atributo llamado edad
    def mostrar_edad(self):  # Es necesario que, al menos, tenga un parámetro, generalmente self
        print(self.edad)     # mostrando un atributo
    def modificar_edad(self, edad):  # Modificando edad
        if 0 > edad < 150:    # Se hace una validación con un condicional
            return False
        else:                 # Si está en el rango 0-150, entonces se modifica la variable
            self.edad = edad  # Se modifica la edad
#+end_src

#+RESULTS:

** Manejando la clase.
#+begin_src python :eval no  :results output :session s1 :exports both 
p = Persona('Daniel', 29)
print(p.nombre)
#+end_src

#+RESULTS:
: Daniel

#+begin_src python :eval no  :results output :session s1 :exports both 
p.nombre = "Danilo"
print(p.nombre)
#+end_src

#+RESULTS:
: Danilo


#+begin_src python :eval no  :results output :session s1 :exports both 
p.mostrar_edad()
p.modificar_edad(41)
p.mostrar_edad()
#+end_src

#+RESULTS:
: 29
: 41

* Módulos

Existen muchas propiedades que se pueden agregar al lenguaje
importando módulos (también llamados paquetes). Estos son conjuntos de
funciones y clases diseñadas para realizar tareas usualmente especiíficas dentro de Python

+ =os= :El módulo os provee funciones para interactuar con el sistema operativo
+ =shutil= : Para tareas de administración de archivos.
+ =glob= : Provee una función para crear listas de archivos a partir de búsquedas con comodines en carpetas.
+ =math= : Permite acceder a las funciones de matemática de punto flotante
+ =random= : Para realizar selecciones al azar
+ =statistics= : se utiliza para estadística básica, por ejemplo: media, mediana, varianza, etc.
+ =datetime= : Para el manejo de fechas y hora.
+ =numpy= :  NumPy o también conocido como Numerical Python, ideal para trabajar con arreglos (arrays) en lugar de listas.
+ =pandas= : Para el análisis, limpieza y manipulación de grandes tablas con datos.


#+begin_src python :eval no :results output :session s1 :exports both 
import statistics as stat
datos = [4.75, 3.55, 1.25, 0.5, 0.35, 1.85, 5.5]
print(stat.mean(datos))
print(stat.median(datos))
print(stat.variance(datos))
#+end_src

#+RESULTS:
: 2.5357142857142856
: 1.85
: 4.293928571428571
